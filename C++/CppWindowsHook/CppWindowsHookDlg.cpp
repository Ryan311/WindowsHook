/****************************** Module Header ******************************\
* Module Name:	CppWindowsHookDlg.cpp
* Project:		CppWindowsHook
* Copyright (c) Microsoft Corporation.
* 
* This project is the user interface of CppWindowsHook sample. It uses the 
* dialog based MFC application template and move the code for the about 
* dialog.
* 
* This source is subject to the Microsoft Public License.
* See http://www.microsoft.com/opensource/licenses.mspx#Ms-PL.
* All other rights reserved.
* 
* History:
* * 5/01/2009 9:04 PM Rong-Chun Zhang Created
\***************************************************************************/

#include "stdafx.h"
#include "CppWindowsHook.h"
#include "CppWindowsHookDlg.h"
#include "NTProcessInfo.h"
#include "GetCmdLine.h"
#include <TlHelp32.h>

#include "../CppHookDll/HookDll.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif


// CCppWindowsHookDlg dialog

CCppWindowsHookDlg::CCppWindowsHookDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CCppWindowsHookDlg::IDD, pParent)
{
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

BEGIN_MESSAGE_MAP(CCppWindowsHookDlg, CDialog)
	ON_MESSAGE(WM_KEYSTROKE, OnHookKeyboard)
	ON_MESSAGE(WM_KEYINPUT, OnHookLowKeyboard)
	ON_BN_CLICKED(IDC_SETHOOK, &CCppWindowsHookDlg::OnBnClickedSethook)
	ON_BN_CLICKED(IDC_SETHOOKTHREAD, &CCppWindowsHookDlg::OnBnClickedSethookthread)
	ON_BN_CLICKED(IDC_SETHOOKINPUT, &CCppWindowsHookDlg::OnBnClickedSethookinput)
	ON_BN_CLICKED(IDC_RESETTEXT, &CCppWindowsHookDlg::OnBnClickedResettext)
	ON_BN_CLICKED(IDC_SETSHELLHOOK, &CCppWindowsHookDlg::OnBnClickedSetshellhook)
	ON_MESSAGE(WM_SHELLNOTIFY, &CCppWindowsHookDlg::OnShellnotify)
END_MESSAGE_MAP()


// CCppWindowsHookDlg message handlers

BOOL CCppWindowsHookDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// Set the icon for this dialog.  The framework does this automatically
	// when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon
	return TRUE;
}

// Hook handler
long CCppWindowsHookDlg::OnHookKeyboard(WPARAM wParam, LPARAM lParam)
{
	CString str;
	GetKeyNameText(lParam, str.GetBuffer(80), 80);
	str.ReleaseBuffer();

	CString strItem(L"User strike:" + str + L"\r\n");

	// Add key data into the editing box
	CString strEdit;
	GetDlgItem(IDC_MSG)->GetWindowText(strEdit);
	GetDlgItem(IDC_MSG)->SetWindowText(strItem + strEdit);

	return 0;
}

// Hook handler(WH_KEYBOARD_LL)
// wParam specifies the virtual key code
// lParam specifies the scan code
long CCppWindowsHookDlg::OnHookLowKeyboard(WPARAM wParam, LPARAM lParam)
{	
	CString str;
	// Convert the virtual key code into a scancode (as required by GetKeyNameText).
	UINT scanCode = MapVirtualKeyEx(wParam, 0, GetKeyboardLayout(0));
    switch(wParam)
    {
		// Certain keys end up being mapped to the number pad by the above function,
		// as their virtual key can be generated by the number pad too.
		// If it's one of the known number-pad duplicates, set the extended bit:
		case VK_INSERT:
		case VK_DELETE:
		case VK_HOME:
		case VK_END:
		case VK_NEXT:  // Page down
		case VK_PRIOR: // Page up
		case VK_LEFT:
		case VK_RIGHT:
		case VK_UP:
		case VK_DOWN:
		  scanCode |= 0x100; // Add extended bit
		  break;
    }      

    // GetKeyNameText() expects the scan code to be on the same format as WM_KEYDOWN
    GetKeyNameText(scanCode << 16, str.GetBuffer(80), 80);
    str.ReleaseBuffer();

	CString strItem(L"Keyboard input:" + str + L"\r\n");

	// Add key data into the editing box
	CString strEdit;
	GetDlgItem(IDC_MSG)->GetWindowText(strEdit);
	GetDlgItem(IDC_MSG)->SetWindowText(strItem + strEdit);

	return 0;
}

// Install or uninstall global keyboard hook
void CCppWindowsHookDlg::OnBnClickedSethook()
{
	CString strButtonText;
	GetDlgItem(IDC_SETHOOK)->GetWindowText(strButtonText);
	if(strButtonText == "Set Hook(Global)")
	{
		// Install Hook
		if (!SetKeyboardHook(TRUE, 0, m_hWnd))
		{
			AfxMessageBox(L"Fail to Install Hook!");
			return;
		}
		GetDlgItem(IDC_SETHOOK)->SetWindowText(L"Unset Hook(Global)");
		GetDlgItem(IDC_SETHOOKTHREAD)->EnableWindow(FALSE);
		GetDlgItem(IDC_SETHOOKINPUT)->EnableWindow(FALSE);
	}
	else
	{
		if (!SetKeyboardHook(FALSE))
		{
			AfxMessageBox(L"Fail to Install Hook!");
			return;
		}
        GetDlgItem(IDC_SETHOOK)->SetWindowText(L"Set Hook(Global)");
		GetDlgItem(IDC_SETHOOKTHREAD)->EnableWindow(TRUE);
		GetDlgItem(IDC_SETHOOKINPUT)->EnableWindow(TRUE);
	}
}

// Install or uninstall thread keyboard hook
void CCppWindowsHookDlg::OnBnClickedSethookthread()
{
	CString strButtonText;
	GetDlgItem(IDC_SETHOOKTHREAD)->GetWindowText(strButtonText);
	if(strButtonText == "Set Hook(Thread)")
	{
		// Install Hook
		if(!SetKeyboardHook(TRUE, ::GetCurrentThreadId(), m_hWnd))
		{
			AfxMessageBox(L"Fail to Install Hook!");
			return;
		}
		GetDlgItem(IDC_SETHOOKTHREAD)->SetWindowText(L"Unset Hook(Thread)");
		GetDlgItem(IDC_SETHOOK)->EnableWindow(FALSE);
		GetDlgItem(IDC_SETHOOKINPUT)->EnableWindow(FALSE);
	}
	else
	{
		if(!SetKeyboardHook(FALSE))
		{
			AfxMessageBox(L"Fail to Install Hook!");
			return;
		}
        GetDlgItem(IDC_SETHOOKTHREAD)->SetWindowText(L"Set Hook(Thread)");
		GetDlgItem(IDC_SETHOOK)->EnableWindow(TRUE);
		GetDlgItem(IDC_SETHOOKINPUT)->EnableWindow(TRUE);
	}
}

void CCppWindowsHookDlg::OnBnClickedSethookinput()
{
	CString strButtonText;
	GetDlgItem(IDC_SETHOOKINPUT)->GetWindowText(strButtonText);
	if(strButtonText == "Set Hook(Input)")
	{
		// Install Hook
		if (!SetLowKeyboardHook(TRUE, 0, m_hWnd))
		{
			AfxMessageBox(L"Fail to Install Hook!");
			return;
		}
		GetDlgItem(IDC_SETHOOKINPUT)->SetWindowText(L"Unset Hook(Input)");
		GetDlgItem(IDC_SETHOOKTHREAD)->EnableWindow(FALSE);
		GetDlgItem(IDC_SETHOOK)->EnableWindow(FALSE);
	}
	else
	{
		if (!SetLowKeyboardHook(FALSE))
		{
			AfxMessageBox(L"Fail to Install Hook!");
			return;
		}
        GetDlgItem(IDC_SETHOOKINPUT)->SetWindowText(L"Set Hook(Input)");
		GetDlgItem(IDC_SETHOOKTHREAD)->EnableWindow(TRUE);
		GetDlgItem(IDC_SETHOOK)->EnableWindow(TRUE);
	}
}

void CCppWindowsHookDlg::OnBnClickedResettext()
{
	GetDlgItem(IDC_MSG)->SetWindowText(NULL);
}


void CCppWindowsHookDlg::OnBnClickedSetshellhook()
{
	// TODO: Add your control notification handler code here
	CString strButtonText;
	GetDlgItem(IDC_SETSHELLHOOK)->GetWindowText(strButtonText);
	if (strButtonText == "Set Shell Hook")
	{
		// Install Hook
		if (!SetShellHook(TRUE, 0, m_hWnd))
		{
			AfxMessageBox(L"Fail to Install Hook!");
			return;
		}
		GetDlgItem(IDC_SETSHELLHOOK)->SetWindowText(L"Unset Shell Hook");
		GetDlgItem(IDC_SETHOOKINPUT)->EnableWindow(FALSE);
		GetDlgItem(IDC_SETHOOKTHREAD)->EnableWindow(FALSE);
		GetDlgItem(IDC_SETHOOK)->EnableWindow(FALSE);
	}
	else
	{
		if (!SetShellHook(FALSE))
		{
			AfxMessageBox(L"Fail to Install Hook!");
			return;
		}
		GetDlgItem(IDC_SETHOOKINPUT)->SetWindowText(L"Set Shell Hook");
		GetDlgItem(IDC_SETHOOKINPUT)->EnableWindow(TRUE);
		GetDlgItem(IDC_SETHOOKTHREAD)->EnableWindow(TRUE);
		GetDlgItem(IDC_SETHOOK)->EnableWindow(TRUE);
	}
}


afx_msg LRESULT CCppWindowsHookDlg::OnShellnotify(WPARAM wParam, LPARAM lParam)
{
	//GetKeyNameText(lParam, str.GetBuffer(80), 80);
	//str.ReleaseBuffer();
	//CWnd* pwnd = CWnd::FromHandle((HWND)wParam);
	//CString strName;
	//pwnd->GetWindowText(strName);
	DWORD ThreadID = -1;
	DWORD ProcessID = -1;
	ThreadID = GetWindowThreadProcessId((HWND)wParam, &ProcessID);
	//HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	//if (hSnapshot == INVALID_HANDLE_VALUE)
	//{
	//	CloseHandle(hSnapshot);
	//	return 0;
	//}

	//CString infoStr;
	//PROCESSENTRY32 pe32;
	//DWORD id = 0;
	//pe32.dwSize = sizeof(PROCESSENTRY32);
	//if (!Process32First(hSnapshot, &pe32))
	//{	
	//	infoStr.Format(_T("Get Process Error, status(%d)"), GetLastError());
	//	CloseHandle(hSnapshot);
	//}
	//else
	//{
	//	do
	//	{
	//		if (ProcessID == pe32.th32ProcessID)
	//		{
	//			infoStr.Format(_T("Process Name is %s"), pe32.szExeFile);
	//			break;
	//		}
	//			
	//	} while (Process32Next(hSnapshot, &pe32));

	//	CloseHandle(hSnapshot);
	//}
	CString csCmdLine;
#if 0

	//Method One:
	{
		smPROCESSINFO pi;
		GetNtProcessInfoViaPid(ProcessID, &pi);
		CString csCmdLine = pi.szCmdLine;
	}
#else
	//Method Two:
	{
		HANDLE hProcess;
		UpgradeProcessPrivilege(GetCurrentProcess(), SE_DEBUG_NAME);	//提升本进程的权限
		PROCESSENTRY32 pe;
		ZeroMemory(&pe, sizeof(PROCESSENTRY32));
		pe.dwSize = sizeof(PROCESSENTRY32);

		hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, ProcessID);	//打开进程
		if (hProcess != 0)
		{
			char *strDestCommand;
			COMMANDLINEINFO cli;
			ZeroMemory(&cli, sizeof(COMMANDLINEINFO));
			if (GetProcessCommandLineInfo(hProcess, &cli))	//获取进程的命令行信息
			{
				try
				{
					strDestCommand = new char[cli.iDestCommandLength + 1];
					ZeroMemory(strDestCommand, cli.iDestCommandLength + 1);
					//读取目标进程的命令行文本
					ReadProcessMemory(hProcess,
						(const void *)cli.dwDestCommand_addr,
						strDestCommand,
						cli.iDestCommandLength,
						NULL);
					//csCmdLine.Format(_T("%s"), strDestCommand);
					csCmdLine = strDestCommand;
					delete[]strDestCommand;
				}
				catch (...)
				{
					//cout << "发生异常！\n" << endl;
					MessageBox(_T("exception happened"));
				}
			}
			else
			{
				//cout << "程序名：" << pe.szExeFile << "\n" << endl;
				MessageBox(_T("Process Name is %s"), pe.szExeFile);
			}
			CloseHandle(hProcess);	//关闭进程句柄
		}
	}
#endif
	CString strID;
	strID.Format(_T("New Process ID(%d) created, CmdLine:  "), ProcessID);
	CString strItem(strID + csCmdLine + L"\r\n");
	// Add key data into the editing box
	CString strEdit;
	GetDlgItem(IDC_MSG)->GetWindowText(strEdit);
	GetDlgItem(IDC_MSG)->SetWindowText(strItem + strEdit);

	return 0;
}
